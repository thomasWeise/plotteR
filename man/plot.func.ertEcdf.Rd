% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ertEcdf.R
\name{plot.func.ertEcdf}
\alias{plot.func.ertEcdf}
\title{Plot ERT-ECDF Functions}
\usage{
\method{plot}{func.ertEcdf}(x, goal = 0, goal.dim = 2L, time.dim = 1L,
  time.type = as.integer, time.min = time.type(1L),
  time.max = time.type(NA_real_), goal.min = 0, goal.max = 1,
  extract.runs = identity, comparator = `<=`, extract.run = identity,
  lineTypeFun = lineTypes.distinct, colorFun = colors.distinct,
  goal.markers = c(0.2, 0.4, 0.6, 0.8), time.markers = NULL,
  legend = NULL, legend.pos = "topleft", legend.cex = NA, ...)
}
\arguments{
\item{x}{the data, maybe a list of [lists of matrices or a list of list of
vectors/lists], where each element has at least the \code{goal.dim} and
\code{time.dim} dimension.}

\item{goal}{the goal value, i.e., the value which must be reached to be
counted as success}

\item{goal.dim}{the dimension where where the goal values can be found}

\item{time.dim}{the dimension where the time values can be found}

\item{time.type}{the type function the time dimension, should be
\code{as.integer} or \code{as.numeric}}

\item{time.min}{the minimum time value to be used for the diagram, or
\code{NA} to use the smallest time value in any run}

\item{time.max}{the maximum time value to be used, or \code{NA} to pick the
maximum time value of any run}

\item{goal.min}{the minimum goal value}

\item{goal.max}{the maximum goal value}

\item{extract.runs}{a function which can be used to extract the run sets from
\code{x}, e.g., \code{identity}}

\item{comparator}{the comparator, usually \code{`<=`} or \code{`>=`}}

\item{extract.run}{a function which can be used to extract the single runs
from the run sets, e.g., \code{identity}}

\item{lineTypeFun}{the line type function, a function returning the line
types to use for a provided number of inputs}

\item{colorFun}{the colors function, a function returning the color list to
use for a provided number of inputs}

\item{goal.markers}{markers for the goal values}

\item{time.markers}{markers for the time values}

\item{legend}{the legend names}

\item{legend.pos}{the legend position (optional, default: topleft)}

\item{legend.cex}{the character sizing for the legend, optional, default
\code{NA}}

\item{...}{Arguments passed on to \code{graphics::plot}
\describe{
  \item{x}{the coordinates of points in the plot. Alternatively, a
      single plotting structure, function or \emph{any \R object with a
        \code{plot} method} can be provided.}
  \item{y}{the y coordinates of points in the plot, \emph{optional}
    if \code{x} is an appropriate structure.}
}}
}
\description{
Plot the Empirical Cumulative Distribution Functions (ECDFs) for
  a couple of different datasets which, in turn, are obtained as Expected Running Times from experiments.
}
\examples{
library("plotteR");

set.seed(10000L);
time.max.pow <- 8;

# create a single run, where the quality dimension reaches to end
make.run <- function(end) {
  repeat {
    x <- sort(unique(as.integer(runif(n=20L, min=1L,
                     max=(10^(runif(n=1L, min=2, max=time.max.pow)))))));
    if(length(x) == 20L) { break; }
  }
  repeat {
    y <- sort(unique(c(end, runif(n=19L, min=end, max=500))), decreasing=TRUE);
    if(length(y) == 20L) {
      break;
    }
  }
  return(matrix(c(x, y), ncol=2L))
}

# make n runs where m reach below 0, i.e., whose ECDF reaches m/n
make.runs <- function(n, m) {
  return(lapply(X=seq_len(n),
                FUN=function(i) {
                  if(i <= m) { end <- runif(n=1L, min=-10L, max=0L); }
                  else       { end <- runif(n=1L, min=1L, max=100L); }
                  return(make.run(end));
                }))
}

# plot five example ECDFs, where the end results reach 3/20, 10/20, 5/20, 15/20,
# and 19/20, respectively
plot.func.ecdf(x = list(make.runs(20, 3),
                        make.runs(20, 10),
                        make.runs(20, 5),
                        make.runs(20, 15),
                        make.runs(20, 19)),
               legend=c("worst", "good", "bad", "better", "best"),
               time.markers=c(1e2, 1e4, 1e6, 1e8),
               log="x",
               time.max=(10^time.max.pow));
}
