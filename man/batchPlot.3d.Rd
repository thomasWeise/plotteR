% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/batchPlot3d.R
\name{batchPlot.3d}
\alias{batchPlot.3d}
\title{Plot 3D Data}
\usage{
batchPlot.3d(data, plotPoints = TRUE, model = .model, predict = .predict,
  modelSteps = 20, legend = NULL, legendWidth = 0.3, ...)
}
\arguments{
\item{data}{the data list, a list of lists where each element
is a list with elements \code{x}, \code{y}, \code{z}, which must be vectors.}

\item{plotPoints}{should the raw points be plotted?}

\item{model}{a \code{function(data)} receiving one item from the \code{data}
list, which i sued for modeling the data, or \code{NULL}, by default a
Kriging-based modeling if no modeling is necessary}

\item{predict}{a \code{function(model, x, y)} for predicting \code{z}
coordinates based on models, or \code{NULL} if no modeling is necessary; by
default a Kriging-based predictor}

\item{modelSteps}{the number of steps for modeling along each axis}

\item{legend}{the legend}

\item{legendWidth}{the fraction of the plot to be allocated for the legend}

\item{...}{Arguments passed on to \code{scatterplot3d::scatterplot3d}
\describe{
  \item{color}{colors of points in the plot, optional if \code{x} is an appropriate structure.
   Will be ignored if \code{highlight.3d = TRUE}.}
  \item{pch}{plotting "character", i.e. symbol to use.}
  \item{main}{an overall title for the plot.}
  \item{sub}{sub-title.}
  \item{xlim}{the x, y and z limits (min, max) of the plot. Note that setting enlarged limits 
    may not work as exactly as expected (a known but unfixed bug).}
  \item{ylim}{the x, y and z limits (min, max) of the plot. Note that setting enlarged limits 
    may not work as exactly as expected (a known but unfixed bug).}
  \item{zlim}{the x, y and z limits (min, max) of the plot. Note that setting enlarged limits 
    may not work as exactly as expected (a known but unfixed bug).}
  \item{xlab}{titles for the x, y and z axis.}
  \item{ylab}{titles for the x, y and z axis.}
  \item{zlab}{titles for the x, y and z axis.}
  \item{scale.y}{scale of y axis related to x- and z axis.}
  \item{angle}{angle between x and y axis (Attention: result depends on scaling).}
  \item{axis}{a logical value indicating whether axes should be drawn on the plot.}
  \item{tick.marks}{a logical value indicating whether tick marks should
   be drawn on the plot (only if \code{axis = TRUE}).}
  \item{label.tick.marks}{a logical value indicating whether tick marks should be labeled on the plot
   (only if \code{axis = TRUE} and \code{tick.marks = TRUE}).}
  \item{x.ticklabs}{vector of tick mark labels.}
  \item{y.ticklabs}{vector of tick mark labels.}
  \item{z.ticklabs}{vector of tick mark labels.}
  \item{y.margin.add}{add additional space between tick mark labels and
   axis label of the y axis}
  \item{grid}{a logical value indicating whether a grid should be drawn on the plot.}
  \item{box}{a logical value indicating whether a box should be drawn around the plot.}
  \item{lab}{a numerical vector of the form c(x, y, len).  The values of
   x and y give the (approximate) number of tickmarks on the x and y axes.}
  \item{lab.z}{the same as \code{lab}, but for z axis.}
  \item{highlight.3d}{points will be drawn in different colors related to y coordinates
   (only if \code{type = "p"} or \code{type = "h"}, else \code{color} will be used).\cr
   On some devices not all colors can be displayed. In this case try the
   postscript device or use \code{highlight.3d = FALSE}.}
  \item{mar}{A numerical vector of the form c(bottom, left, top, right)
   which gives the lines of margin to be specified on the four sides of the plot.
   See section Values on how to change the setting back to the default / previous setting.}
  \item{bg}{background (fill) color for the open plot symbols given by pch = 21:25.}
  \item{col.axis}{the color to be used for axis / grid / axis labels.}
  \item{col.grid}{the color to be used for axis / grid / axis labels.}
  \item{col.lab}{the color to be used for axis / grid / axis labels.}
  \item{cex.symbols}{the magnification to be used for
   point symbols, axis annotation, labels relative to the current.}
  \item{cex.axis}{the magnification to be used for
   point symbols, axis annotation, labels relative to the current.}
  \item{cex.lab}{the magnification to be used for
   point symbols, axis annotation, labels relative to the current.}
  \item{font.axis}{the font to be used for axis annotation / labels.}
  \item{font.lab}{the font to be used for axis annotation / labels.}
  \item{lty.axis}{the line type to be used for axis / grid.}
  \item{lty.grid}{the line type to be used for axis / grid.}
  \item{lty.hide}{line style used to plot \sQuote{non-visible} edges (defaults of the \code{lty.axis} style)}
  \item{lty.hplot}{the line type to be used for vertical segments with \code{type = "h"}.}
  \item{log}{Not yet implemented!  A character string which contains "x"
   (if the x axis is to be logarithmic), "y", "z", "xy", "xz", "yz", "xyz".}
  \item{asp}{numeric, giving the \bold{asp}ect ratio z/x or z/y, see \sQuote{Note}.}
}}
}
\description{
The list \code{x} contains, in turn,
lists which have the elements \code{x}, \code{y}, \code{z},
each of which represent one dataset to be plotted.
}
\examples{
library(plotteR)

# set a random seed for replicability
set.seed(1000L);

# generate the first example dataset
f1 <- function(x, y) (x*x - y*y);
x1 <- runif(n=400, min=-2, max=2);
y1 <- runif(n=400, min=-2, max=2);
z1 <- f1(x1, y1);
d1 <- list(x=x1, y=y1, z=z1);

# generate the second example dataset
f2 <- function(x, y) 0.8*x + 0.25*y - 7;
x2 <- runif(n=400, min=-2, max=2);
y2 <- runif(n=400, min=-2, max=2);
# here we even add a bit of randomness into the data
z2 <- rnorm(n=400, mean=f2(x2, y2), sd=0.3);
d2 <- list(x=x2, y=y2, z=z2);

# plot the data together with the interpolated surfaces
batchPlot.3d(list(d1, d2), plotPoints=TRUE, legend=c("f1", "f2"), legendWidth=0.1);

readline("Press return to continue");

# now we just plot the actual surfaces for comparison.
d1$f <- f1;
d2$f <- f2;
batchPlot.3d(list(d1, d2), plotPoints=FALSE, legend=c("f1", "f2"),
             model=function(d) d$f,
             predict=function(m, x, y) m(x, y), legendWidth=0.1);
}
